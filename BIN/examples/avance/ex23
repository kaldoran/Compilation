#!/usr/bin/cpyrr
# -*- coding: utf-8 -*-

% TESTS_STRUCTURES_ET_TABLEAUX %

# Un Point
type Point :
  struct
    x : int;
    y : int;
    size : int;
  end struct;

# Une liste de 50 points
type List : array[0..50] of Point;

# Un ensemble contient le nombre de points courants 
# + la liste correspondante
type ensemble : 
  struct
    size : int;
    content : List;
  end struct;

# Données
var valeurs : ensemble;

# Remplir aléatoirement un type ensemble
proc remplir(ensemble : Point)
  var i : int;
  var v : List;
  start
  {
    v[0].size = 0;

    for(i = 0; i < 50; i++) do {
      v[i].x = rand() * 101;
      v[i].y = rand() * 101;
      v[0].size += v[i].x * v[i].x + v[i].y * v[i].y;
    }
 
    return;
  };

# Affichage de l'ensemble
proc afficher()
  var i : int;
  var v : List;
  start
  { 
    write("Size: %d\n", v[i].size);

    for(i = 0; i < 50;) do {
      write("(%d, %d)", v[i].x, v[i].y); 

      if (i++) == 49 then { write("\n"); }
      else { write(","); }
    }

    return;
  };

# Recherche une coordonnée
function search_point(x : int, y : int) return bool
  var i,x, y : int;
  var v : List;
  start
  {
    for(i = 0; i < 50;) do {
      if v[i].x == x and v[i].y == y then {
        return true;
      }
    } 
    
    return false;
  };

# Je cherche moi-même l'utilité de cette fonction...
function machin_bidule(x : int) return int
  proc truc(y : int)
    var k, y, x : int;
   
    proc mise_k()
      start
      {
        k = 0;
      };

    proc get_k ()
      var ooooo : char;
      start
      {
        read(k);
      };

    start
    {
      write("%d\n", y);
      
      if y then {
        mise_k(); /* on me dit qu'elle a un parametre ! */
      }
      else {
        get_k(); /* Pareil */
      }
    };
  
  var p,x : int;

  start
  {
    truc(x * 100);
    x++;
    return x;
  };


# Programme
start
{
 ; # Pour la peine, on ne fait rien
}
